{
  "descripcion": "La **inyección SQL** es una de las vulnerabilidades más peligrosas y frecuentes en aplicaciones web.  \nOcurre cuando una aplicación construye consultas SQL de forma insegura, permitiendo que un usuario malicioso inserte código SQL propio en los campos de entrada (como formularios de login, búsqueda o parámetros en la URL).\n\nSi una aplicación no valida ni filtra correctamente los datos que recibe del usuario, un atacante puede manipular las consultas a la base de datos. Esto puede permitirle:\n\n- Acceder a información confidencial (usuarios, contraseñas, datos personales...)\n- Modificar, borrar o insertar datos en la base de datos\n- Eludir controles de autenticación y acceder como otro usuario\n- Obtener acceso total al sistema en casos graves\n\nPor ejemplo, si un formulario de login construye la consulta SQL directamente con los datos introducidos por el usuario, un atacante podría alterar la lógica de autenticación y acceder sin conocer la contraseña.\n\nEn este módulo aprenderás a identificar, explotar y entender el impacto de la inyección SQL, así como a proteger tus aplicaciones frente a este tipo de ataques.\n\n### ¿Quieres saber más?\n\nConsulta estos recursos recomendados:\n\n- [OWASP: SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) \n- [OWASP Cheat Sheet: Prevención de SQL Injection](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html) \n- [PortSwigger Web Security Academy: SQL Injection](https://portswigger.net/web-security/sql-injection) \n- [Hacksplaining: Ejercicio interactivo de SQL Injection](https://www.hacksplaining.com/exercises/sql-injection)\n",
  "descripcionEjercicios": "## Ejercicio 1: Login vulnerable\n\nEl primer paso para acceder a la tienda es iniciar sesión. El formulario de login es vulnerable a inyección SQL,  \nlo que significa que puedes acceder como cualquier usuario sin conocer su contraseña real.\n\n## Ejercicio 2: Filtros avanzados vulnerables\n\nUtiliza los filtros de búsqueda (nombre, categoría) en el catálogo. Todos los filtros son vulnerables a inyección SQL.  \n¿Podrás encontrar productos ocultos o manipular los resultados?\n\n## Ejercicio 3: Detalles de producto vulnerables\n\nUna vez dentro, puedes ver el catálogo de productos. Si haces clic en un producto, accederás a una pantalla de detalle.\n\nSin embargo, los productos de la categoría \"Oculta\" no son visibles a menos que manipules la URL.\n\nEl endpoint que obtiene los detalles es vulnerable a inyección SQL, así que puedes manipular el parámetro `id` en la URL para intentar acceder a productos ocultos o a información de otros productos.\n",
  "pistas": {
    "1": {
      "facil": "Recuerda que en los formularios de login vulnerables a SQLi, puedes intentar modificar el campo de usuario o contraseña para alterar la consulta SQL. Piensa en cómo podrías hacer que la condición del WHERE siempre sea verdadera.",
      "medio": "No puedes usar comillas simples ni dobles. Intenta una inyección SQL sin comillas en el campo de usuario o contraseña.",
      "dificil": "Las inyecciones clásicas no funcionan. Prueba técnicas avanzadas como blind SQLi o error-based SQLi si el backend muestra errores.",
      "imposible": "No es posible explotar la vulnerabilidad en este nivel. Solo podrás acceder con credenciales válidas."
    },
    "2": {
      "facil": "Los campos de búsqueda y categoría también se usan en consultas SQL. Intenta escribir algo inesperado para ver si puedes mostrar productos ocultos.",
      "medio": "No puedes usar comillas. Prueba una inyección SQL sin comillas en el campo de búsqueda.",
      "dificil": "Prueba técnicas avanzadas, como usar comentarios, funciones o subconsultas si el backend lo permite.",
      "imposible": "No es posible mostrar productos ocultos mediante inyección SQL en este nivel."
    },
    "3": {
      "facil": "El parámetro id en la URL se utiliza directamente en la consulta SQL. Intenta modificarlo en la barra de direcciones para ver si puedes acceder a otros productos o productos ocultos.",
      "medio": "No puedes usar comillas. Prueba a modificar el parámetro id en la URL usando una inyección sin comillas.",
      "dificil": "Las inyecciones clásicas no funcionan. Prueba técnicas avanzadas, como blind SQLi, si el backend muestra errores.",
      "imposible": "No es posible explotar la vulnerabilidad en el parámetro id en este nivel."
    }
  },
  "soluciones": {
  "1": {
    "facil": "1. En el campo de usuario escribe: `admin' OR 1=1 --` (o en el campo de contraseña).\n2. Pulsa \"Iniciar sesión\".\n3. Accederás sin necesidad de conocer la contraseña.",
    "medio": "1. No puedes usar comillas simples ni dobles.\n2. Prueba con: `0 OR 1=1 --` en el campo de usuario.\n3. Pulsa \"Iniciar sesión\".\n4. Si el backend lo permite, accederás sin contraseña.",
    "dificil": "1. Las inyecciones clásicas no funcionan.\n2. Prueba técnicas avanzadas como **blind SQLi**:\n3. Intenta con: `admin' AND 1=1 --` y observa si cambia el mensaje de error. Si el backend muestra errores, puedes intentar deducir información carácter a carácter.\n4. Si no hay mensajes de error, prueba con combinaciones y observa el comportamiento.",
    "imposible": "No es posible explotar la vulnerabilidad. Solo podrás acceder con credenciales válidas."
  },
  "2": {
    "facil": "1. En el campo de búsqueda, escribe: `' OR 1=1 --`\n2. Pulsa \"Buscar\".\n3. Deberías ver todos los productos, incluyendo los de la categoría \"Oculta\".",
    "medio": "1. No puedes usar comillas dobles, pero sí comillas simples.\n2. Prueba con: `%' OR 1=1 --`\n3. Pulsa \"Buscar\" y deberías ver productos ocultos.",
    "dificil": "1. Prueba técnicas avanzadas, como usar comentarios, funciones o subconsultas si el backend lo permite.\n2. Ejemplo: `a%' OR 1=1 --`\n3. Observa si logras mostrar productos ocultos.",
    "imposible": "No es posible mostrar productos ocultos mediante inyección SQL."
  },
  "3": {
    "facil": "1. Haz clic en cualquier producto para ir a la página de detalle.\n2. En la URL, cambia el parámetro `id` por: `1 OR 1=1`\n3. Ejemplo: `/modulo/sql-inyeccion/tienda/producto?id=1 OR 1=1`\n4. Pulsa Enter. Tras probar con diferentes IDs, ¡encontrarás un producto oculto!",
    "medio": "1. No puedes usar comillas ni letras, pero sí operadores y el signo igual.\n2. Prueba con: `1=1` o `3|1=1` en el parámetro `id` de la URL.\n3. Ejemplo: `/modulo/sql-inyeccion/tienda/producto?id=1=1`\n4. Pulsa Enter. Si el backend lo permite, verás el producto con id=1 (o el primero de la tabla), aunque pongas cualquier id.",
    "dificil": "1. Las inyecciones clásicas no funcionan.\n2. Prueba con técnicas avanzadas, por ejemplo: `1 AND (SELECT SUBSTR(nombre,1,1) FROM productos WHERE id=1)=65`\n3. Observa si el comportamiento cambia o si puedes deducir información.",
    "imposible": "No es posible explotar la vulnerabilidad en el parámetro `id`."
  }
  },
  "explicaciones": {
    "facil": "### Nivel Fácil\nEl backend construye las consultas SQL directamente con los datos del usuario, sin ningún tipo de validación ni filtrado. Esto significa que puedes usar comillas, operadores lógicos y cualquier payload clásico de inyección SQL. Es el escenario más vulnerable y didáctico para practicar ataques básicos.\n\n```python\n# Login\nquery = f\"SELECT * FROM usuarios WHERE nombre = '{username}' AND email = '{password}'\"\ncursor.execute(query)\n\n# Productos\nquery = f\"SELECT * FROM productos WHERE nombre LIKE '%{search}%' AND categoria != 'Oculta'\"\ncursor.execute(query)\n\n# Detalle de producto\nquery = f\"SELECT * FROM productos WHERE id = {prod_id}\"\ncursor.execute(query)\n```\nPuedes romper la consulta fácilmente y acceder como cualquier usuario, o mostrar todos los productos, incluidos los ocultos, con inyecciones clásicas como `' OR 1=1 --`.",
    "medio": "### Nivel Medio\nEl backend filtra comillas simples y dobles, pero sigue sin usar consultas preparadas. Inserta los datos del usuario directamente en la consulta SQL, pero sin comillas alrededor de los valores en login, y con comillas en productos. Además, en el detalle de producto solo permite números y operadores aritméticos, pero sigue siendo vulnerable a ciertas inyecciones.\n\n```python\n# Login\nif \"'\" in username or '\"' in username or \"'\" in password or '\"' in password:\n    return error\nquery = f\"SELECT * FROM usuarios WHERE nombre = {username} AND email = {password}\"\ncursor.execute(query)\n\n# Productos\nif '\"' in search:\n    return error\nif not search:\n    search = '%'\nquery = f\"SELECT * FROM productos WHERE nombre LIKE '{search}' AND categoria != 'Oculta'\"\ncursor.execute(query)\n\n# Detalle de producto\nimport re\nif not re.match(r'^[0-9\\s\\-+*/%()=|&]+$', prod_id):\n    return error\nquery = f\"SELECT * FROM productos WHERE id = {prod_id}\"\ncursor.execute(query)\n```\nEsto permite inyecciones SQL **sin comillas** en login (por ejemplo, `0 OR 1=1 --`), inyecciones con comillas en productos (por ejemplo, `%' OR 1=1 --`), y en el detalle de producto puedes usar operadores y el signo igual (por ejemplo, `1=1` o `3|1=1`). Es más difícil que el nivel fácil, pero sigue siendo vulnerable.",
    "dificil": "### Nivel Difícil\nEl backend utiliza **consultas preparadas (parametrizadas)**, lo que impide la inyección SQL clásica. Sin embargo, si ocurre un error SQL, el backend muestra el mensaje de error en la respuesta. Esto puede permitir ataques avanzados como **error-based SQLi** o **blind SQLi** si el atacante es creativo y el backend expone información sensible.\n\n```python\n# Login\nquery = \"SELECT * FROM usuarios WHERE nombre = ? AND email = ?\"\ncursor.execute(query, (username, password))\n\n# Productos\nquery = \"SELECT * FROM productos WHERE nombre LIKE ? AND categoria != 'Oculta'\"\ncursor.execute(query, (f\"%{search}%\",))\n\n# Detalle de producto\nquery = \"SELECT * FROM productos WHERE id = ?\"\ncursor.execute(query, (prod_id,))\n```\nLa inyección clásica no funciona, pero podrías intentar técnicas avanzadas si el backend muestra errores detallados.",
    "imposible": "### Nivel Imposible\nEl backend utiliza **consultas preparadas** y además **no muestra mensajes de error SQL** al usuario. Esto elimina prácticamente cualquier vector de inyección SQL, incluso los más avanzados, y no expone información interna del sistema.\n\n```python\n# Login\nquery = \"SELECT * FROM usuarios WHERE nombre = ? AND email = ?\"\ncursor.execute(query, (username, password))\n\n# Productos\nquery = \"SELECT * FROM productos WHERE nombre LIKE ? AND categoria != 'Oculta'\"\ncursor.execute(query, (f\"%{search}%\",))\n\n# Detalle de producto\nquery = \"SELECT * FROM productos WHERE id = ?\"\ncursor.execute(query, (prod_id,))\n```\nNo es posible explotar la inyección SQL en este nivel. Solo puedes acceder con credenciales válidas y no obtendrás información extra aunque provoques errores."
},
  "ejemplo": "Imagina que una aplicación tiene esta consulta para verificar si un usuario existe:\n\n```sql\nSELECT * FROM usuarios WHERE nombre = 'Pepe' AND contraseña = '1234'\n```\n\nUn atacante podría introducir esto en el campo de nombre de usuario:\n\n```sql\nPepe' OR 1=1 --\n```\n\nEntonces, la consulta quedaría así:\n\n```sql\nSELECT * FROM usuarios WHERE nombre = 'Pepe' OR 1=1 --' AND contraseña = ''\n```\n\nEste código haría que se devuelvan todos los usuarios, ignorando la contraseña, ¡y el atacante podría acceder sin conocer la contraseña!"

}